# 基本内容
## 关系型数据库
基于表结构存储数据，常见的有 MySQL、PostgreSQL、Oracle 等。数据由行（记录）和列（字段）构成，通过主键、外键来维护表与表之间的关系。
## 非关系型数据库
如 MongoDB、Redis 等，适用于海量数据、高并发场景，通常不强调固定模式（schema）。
## SQL 与 NoSQL
SQL 用于结构化查询语言，主要操作关系型数据库；NoSQL 更灵活，适用于结构不固定或数据量巨大的场景。
# 事务与 ACID
数据库事务是数据库管理系统执行过程中的一个逻辑单元，它由一系列数据库操作组成，这些操作要么全部成功执行，要么全部不执行，以保证数据库的一致性和完整性。

数据库事务拥有以下四个特性，被称之为ACID特性：

- 原子性（Atomicity）

  事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。

- 一致性（Consistency）

  事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。

- 隔离性（Isolation）

  多个事务并发执行时，一个事务的执行不应影响其他事务的执行。

- 持久性（Durability）

  已被提交的事务对数据库的修改应该永久保存在数据库中。
# 索引结构
## B+ 树
B+树是一种多路平衡查找树，所有数据都存放在叶子节点，内部节点只存储键值及指向子节点的指针。

特点：

- 适合范围查询和排序

- 查询时间复杂度为 O(log n)

- MySQL InnoDB 存储引擎默认使用 B+树作为主键索引结构

> 索引结构为什么要选择B+树？：
>
> （1）所有数据存储在叶子节点，这种设计**便于范围查询和顺序遍历**，因为叶子节点之间通常通过指针连接，能够高效地实现区间扫描；（2）磁盘 I/O 友好， B+ 树节点的大小通常与磁盘页大小匹配，可以充分利用每次磁盘读写的数据量，减少 I/O 操作，提高查询性能；（3）稳定的平衡性，B+ 树在插入和删除操作后能够保持平衡，这确保了无论数据量如何变化，查询、插入和删除操作的时间复杂度都维持在 O(log n) 范围内，从而保证了数据库的高性能。
>
> B树、B+树区别？：
>
> （1）节点结构：B 树每个节点包含关键字和数据指针；B + 树非叶子节点只包含关键字和子树指针，不存储数据记录，叶子节点包含了全部关键字以及指向对应数据记录的指针，并且叶子节点之间通过双向链表连接（2）查找方式：B 树从根节点开始，通过比较关键字来决定搜索路径，直到找到目标关键字或确定目标不存在；B + 树从根节点开始搜索，只有在叶子节点才能找到数据记录。不过由于叶子节点是有序的且通过链表相连，对于范围查询等操作，B + 树可以更高效地进行遍历
## 位图索引
通过使用位图（bit map）记录数据在表中的存在情况，适用于低基数（distinct values 较少）的列。

特点：

- 占用空间较小，适合只读或更新较少的场景

- 主要用于数据仓库或OLAP场景
# 并发控制
数据库中的**锁机制**是实现并发控制的重要手段，用于确保在多用户环境下数据的一致性和完整性。
## 行锁
行锁是一种粒度较细的锁，它锁定的是表中的某一行数据。当一个事务对某一行进行操作（如更新、删除）时，会获取该行的锁，其他事务在该锁释放之前不能对同一行进行冲突的操作。
## 表锁
表锁是对整个表进行锁定。当一个事务获取了表锁后，其他事务在该锁释放之前不能对该表进行任何写操作，读操作是否允许取决于表锁的类型（共享表锁允许读操作，排他表锁不允许读操作）。
## 乐观锁
乐观锁是一种基于数据版本号或时间戳的并发控制机制。它假设在大多数情况下，并发事务之间不会发生冲突，只有在更新数据时才会检查数据是否被其他事务修改过。通常在表中添加一个版本号字段或时间戳字段，每次更新数据时，版本号会递增或时间戳会更新。
## 悲观锁
悲观锁与乐观锁相反，它假设并发事务之间很可能会发生冲突，因此在事务开始时就对数据进行加锁，直到事务结束才释放锁。在加锁期间，其他事务无法对被锁定的数据进行访问。
# SQL 基础
### 数据定义
~~~
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    department VARCHAR(50)
);
~~~
~~~
-- 添加列
ALTER TABLE employees ADD COLUMN salary DECIMAL(10, 2);
-- 删除列
ALTER TABLE employees DROP COLUMN age;
DROP TABLE employees;
~~~
## 数据查询
~~~
SELECT * FROM employees WHERE department = 'HR';
SELECT * FROM employees ORDER BY salary DESC;
SELECT COUNT(*) FROM employees;
SELECT AVG(salary) FROM employees;
SELECT department, COUNT(*) FROM employees GROUP BY department;
~~~
### 数据操作
~~~
INSERT INTO employees (id, name, department, salary) VALUES (1, 'John Doe', 'HR', 5000.00);
UPDATE employees SET salary = 5500.00 WHERE id = 1;
DELETE FROM employees WHERE id = 1;
~~~
### 数据控制
~~~
GRANT SELECT, INSERT ON employees TO 'user'@'localhost';
REVOKE INSERT ON employees FROM 'user'@'localhost';
~~~
