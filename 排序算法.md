# 冒泡排序
原理： 重复地遍历待排序的数组，比较相邻的元素并进行交换，使较大的元素逐渐“冒泡”到数组的末尾。​

时间复杂度： 平均和最坏情况下为 O(n²)；最好情况下（数组已排序）为 O(n)。​

空间复杂度： O(1)。​

稳定性： 稳定。
# 插入排序
原理： 将未排序的元素逐个插入到已排序部分的适当位置。​

时间复杂度： 平均和最坏情况下为 O(n²)；最好情况下为 O(n)。​

空间复杂度： O(1)。​

稳定性： 稳定。
# 选择排序
原理： 每次从未排序部分选择最小的元素，放到已排序部分的末尾。​

时间复杂度： 无论什么情况，均为 O(n²)。​

空间复杂度： O(1)。​

稳定性： 不稳定。
# 快速排序
原理： 选择一个基准元素，将数组分为小于基准和大于基准的两部分，递归排序。​

时间复杂度： 平均情况为 O(nlogn)；最坏情况下为 O(n²)。​

空间复杂度： O(logn)（递归调用栈）。​

稳定性： 不稳定。
# 希尔排序
原理： 基于插入排序，通过将数据分组，对每组分别进行插入排序，逐步减少间隔，最终完成排序。​

时间复杂度： 平均情况为 O(nlogn)；最坏情况下为 O(n²)。​

空间复杂度： O(1)。​

稳定性： 不稳定。
# 归并排序
原理： 采用分治策略，将数组分成两部分，分别排序后再合并。​

时间复杂度： 无论什么情况，均为 O(nlogn)。​

空间复杂度： O(n)。​

稳定性： 稳定。
# 堆排序
原理： 利用堆这种数据结构，将数组构建成最大堆，然后依次取出堆顶元素，调整堆结构，完成排序。​

时间复杂度： 无论什么情况，均为 O(nlogn)。​

空间复杂度： O(1)。​

稳定性： 不稳定。
