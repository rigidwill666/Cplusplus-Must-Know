# 基础概念
堆是由程序员手动管理的动态内存区域，需要使用 new / malloc 分配，delete / free 释放。

栈是由**编译器**自动管理的内存区域，用于存放局部变量、函数参数和返回值。

> 为什么栈的访问速度通常比堆快？：
> 
> 栈的地址是连续的，栈数据符合 CPU 缓存优化策略，CPU 访问时更高效；堆的地址可能是分散的，每次访问都可能涉及**指针间接寻址**，堆数据访问可能会产生更多缓存未命中，导致访问慢。
# 对比
- 堆

  动态分配：手动申请和释放，生命周期由程序员管理。

  存储位置：位于进程的**堆区**（低地址向高地址增长，即向地址较大的方向分配）。
  
  访问速度较慢：存储在二级缓存或主存中，由于动态分配需要管理内存碎片，访问速度比栈慢。

  > 内存碎片？：
  >
  > 指在计算机内存管理过程中，由于频繁的内存分配和释放，导致内存空间无法被高效利用的现象。主要分为内部碎片和外部碎片。当分配的内存块大于实际使用的内存，多余的部分被浪费，形成内部碎片；由于频繁的内存分配和释放，导致大量小块空闲内存分布在不同位置，无法满足大块内存请求，形成外部碎片。
  > 如何减少内存碎片？：
  >
  > 减少动态内存分配；使用内存池（预先申请一大块内存，从内存池中分配一个固定大小的块而不是调用 new 或 malloc，释放不会真正归还给操作系统，而是放回内存池）；合并空闲块（一些操作系统支持垃圾回收（GC），自动整理内存）
  
  大小不固定：可以根据需求动态调整分配大小。
  
  容易产生内存泄漏：忘记 delete / free 会造成内存泄漏。
  > 什么是内存泄漏？：
  > 
  > 内存泄漏指的是程序在运行过程中，由于某些原因未能正确释放不再使用的内存，导致这部分内存无法被系统再次分配使用。随着程序的持续运行，泄漏的内存会不断累积，最终可能耗尽系统的可用内存，使程序运行变慢甚至崩溃。
  >
  > 内存泄漏检测方法？：
  >
  > 1.静态代码分析工具（在不运行程序的情况下对源代码进行扫描，如Cppcheck）；2. 动态内存分析工具（在程序运行时监控内存的分配和释放情况，如Valgrind）；3.日志记录与统计（在代码中添加日志记录，记录内存分配和释放的操作，通过统计分配和释放的次数是否匹配来判断是否存在内存泄漏）；4.垃圾回收机制语言中的工具（如Python 的objgraph）
- 栈

  自动分配和释放：无需手动管理，编译器自动分配和回收。

  存储位置：位于进程的**栈区**（高地址向低地址增长，即向地址较小的方向分配）。
  
  访问速度快：使用一级缓存存储在处理器核心中，LIFO（后进先出）结构，分配和释放效率高。
  
  大小固定：每个线程的栈大小通常是有限的（一般几 MB）。
  
  容易栈溢出：深递归或大量局部变量可能导致 stack overflow。
  > 如何避免栈溢出？：
  >
  > 使用迭代替代递归；减少局部变量的使用，合理使用全局变量或静态变量，避免创建过大的局部数组；控制递归深度；增加栈空间

> 如何用 new/delete 在堆上分配内存？malloc/free 与它们的区别？：
>
> new 是C++的关键字，而 malloc 是C语言的库函数；new 分配并自动调用对象的构造函数初始化，delete 释放并调用析构函数，返回具体类型指针；malloc 只分配不调用构造函数，得到的内存空间内容是未初始化的，free 释放但不调用析构函数，返回 void*，需要手动转换；new 可以通过异常机制检测内存分配失败，而 malloc 在分配失败时返回 NULL，需要手动检查。
