# hashmap
在 C++ 中，无序std::unordered_map（也可以称为 hash_map）的底层存储结构是**哈希表** ，通常使用**哈希桶+链地址法**来处理哈希冲突。
## 存储结构
哈希桶：哈希表的存储单元，每个桶存储**多个键值对**。
哈希函数：计算 key 的哈希值，并决定存放到哪个桶（索引）。
链地址法：解决哈希冲突，即在相同的桶中存储多个元素（通常用**链表**或**动态数组**）。
## 底层关键机制
### 哈希函数
~~~
unordered_map 依赖 hash<Key> 来计算哈希值：
std::hash<int> hash_fn;
size_t hash_value = hash_fn(5);  // 计算键 5 的哈希值

哈希值通过 bucket_count 计算索引：
bucket_index = hash_value % bucket_count;
~~~
### 处理哈希冲突
采用**链地址法**，即同一个桶内使用链表或数组存储多个元素。也有的实现使用**开放地址法**，但 unordered_map 通常默认用链地址法。
### 负载因子与 Rehash
负载因子：元素个数 / 桶数，默认最大值约为 1.0。
当负载因子超过阈值，会进行 rehash（扩容）：
- 桶数量增大（一般是 2 倍）
- 重新计算所有元素的哈希值
- 重新分配到新的桶
## 复杂度
插入、删除、查找平均复杂度 O(1)，最坏情况 O(n)；遍历 O(n)。
# map
std::map 的底层数据结构是**红黑树（有序）**，它是一种**自平衡二叉搜索树**。
## 红黑树特点
1. 自动排序：插入元素时，根据 key 进行排序（默认使用 operator<）。
2. 自平衡：树的最长路径不会超过最短路径的 2 倍，确保 O(log n) 复杂度。
3. 二叉搜索性质。
4. 红黑树的 5 条性质（保证树不会退化成链表）：
- 根节点是黑色的。
- 每个叶子节点（NIL）是黑色的。
- 红色节点的子节点必须是黑色的（红色不能连续）。
- 每个叶子节点到根的路径，黑色节点数量相同。
- 插入或删除时，旋转 + 重新着色，保持平衡。
## 复杂度
插入、删除、查找复杂度 O(logn)；遍历 O(n)。



