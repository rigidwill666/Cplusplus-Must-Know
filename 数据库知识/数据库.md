# 基本内容
## 关系型数据库
基于表结构存储数据，常见的有 MySQL、PostgreSQL、Oracle 等。数据由行（记录）和列（字段）构成，通过主键、外键来维护表与表之间的关系。
## 非关系型数据库
如 MongoDB、Redis 等，适用于海量数据、高并发场景，通常不强调固定模式（schema）。
## SQL 与 NoSQL
SQL 用于结构化查询语言，主要操作关系型数据库；NoSQL 更灵活，适用于结构不固定或数据量巨大的场景。

> MySQL 和 Redis区别？：
>
> （1）**数据模型**：前者是结构化数据，支持 SQL 查询；后者是非结构化数据（键值、哈希、列表等），无复杂查询（2）**数据持久化**：前者数据持久化到磁盘，支持事务 ACID；后者默认内存存储，可选 RDB/AOF 持久化，不保证强一致性（3）​​**性能**：前者单次操作较慢（毫秒级），适合复杂查询；后者内存操作极快（微秒级），适合高频读写（4）**​​扩展性**：前者​​垂直扩展为主；后者水平扩展容易（分布式集群）（5）**典型用途**​​：前者持久化存储、复杂事务、数据分析；后者缓存加速（如缓存热门商品信息，避免频繁查询数据库）、实时计算（如实时弹幕处理、排行榜更新、限流计数）、高频读写（如统计网站实时在线用户数）、临时数据存储（如存储用户登录后的 Session 信息）
>
> 通过合理分工，两者可互补：​​MySQL 保证数据可靠性，Redis 提升性能与实时性​​。
# 事务与 ACID
数据库事务是数据库管理系统执行过程中的一个逻辑单元，它由一系列数据库操作组成，这些操作要么全部成功执行，要么全部不执行，以保证数据库的一致性和完整性。

数据库事务拥有以下四个特性，被称之为ACID特性：

- 原子性（Atomicity）

  事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。

- 一致性（Consistency）

  事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。

- 隔离性（Isolation）

  多个事务并发执行时，一个事务的执行不应影响其他事务的执行。

- 持久性（Durability）

  已被提交的事务对数据库的修改应该永久保存在数据库中。
# 索引结构
## B+ 树
B+树是一种多路平衡查找树，所有数据都存放在叶子节点，内部节点只存储键值及指向子节点的指针。

特点：

- 适合范围查询和排序
- 查询时间复杂度为 O(log n)
- MySQL InnoDB 存储引擎默认使用 B+树作为主键索引结构

> 索引结构为什么要选择B+树？：
>
> （1）所有数据存储在叶子节点，这种设计**便于范围查询和顺序遍历**，因为叶子节点之间通常通过指针连接，能够高效地实现区间扫描；（2）磁盘 I/O 友好， B+ 树节点的大小通常与磁盘页大小匹配，可以充分利用每次磁盘读写的数据量，减少 I/O 操作，提高查询性能；（3）稳定的平衡性，B+ 树在插入和删除操作后能够保持平衡，这确保了无论数据量如何变化，查询、插入和删除操作的时间复杂度都维持在 O(log n) 范围内，从而保证了数据库的高性能。
>
> B树、B+树区别？：
>
> （1）节点结构：B 树每个节点包含关键字和数据指针；B + 树非叶子节点只包含关键字和子树指针，不存储数据记录，叶子节点包含了全部关键字以及指向对应数据记录的指针，并且叶子节点之间通过双向链表连接（2）查找方式：B 树从根节点开始，通过比较关键字来决定搜索路径，直到找到目标关键字或确定目标不存在；B + 树从根节点开始搜索，只有在叶子节点才能找到数据记录。不过由于叶子节点是有序的且通过链表相连，对于范围查询等操作，B + 树可以更高效地进行遍历
## 哈希索引
哈希索引基于哈希表实现。当创建哈希索引时，数据库会对索引列的值计算哈希码，然后根据哈希码将数据存储在对应的哈希桶中。每个哈希桶可以存储一个或多个数据记录。

特点：

- 等值查询速度快，实现简单
- 不支持范围查询，排序性能差，哈希冲突
## 位图索引
通过使用位图（bit map）记录数据在表中的存在情况，适用于低基数（distinct values 较少）的列。

特点：

- 占用空间较小，适合只读或更新较少的场景
- 主要用于数据仓库或OLAP场景
# 并发控制
数据库中的**锁机制**是实现并发控制的重要手段，用于确保在多用户环境下数据的一致性和完整性。
## 行锁
行锁是一种粒度较细的锁，它锁定的是表中的某一行数据。当一个事务对某一行进行操作（如更新、删除）时，会获取该行的锁，其他事务在该锁释放之前不能对同一行进行冲突的操作。
## 表锁
表锁是对整个表进行锁定。当一个事务获取了表锁后，其他事务在该锁释放之前不能对该表进行任何写操作，读操作是否允许取决于表锁的类型（共享表锁允许读操作，排他表锁不允许读操作）。
## 乐观锁
乐观锁是一种基于数据版本号或时间戳的并发控制机制。它假设在大多数情况下，并发事务之间不会发生冲突，只有在更新数据时才会检查数据是否被其他事务修改过。通常在表中添加一个版本号字段或时间戳字段，每次更新数据时，版本号会递增或时间戳会更新。
## 悲观锁
悲观锁与乐观锁相反，它假设并发事务之间很可能会发生冲突，因此在事务开始时就对数据进行加锁，直到事务结束才释放锁。在加锁期间，其他事务无法对被锁定的数据进行访问。
# 隔离级别
数据库的隔离级别定义了事务在并发执行时的可见性规则，旨在平衡数据一致性与性能。

核心目标：解决并发问题​​——脏读、不可重复读、幻读；权衡一致性与时效性​​——隔离级别越高，数据一致性越强，但并发性能越低。
## READ UNCOMMITTED（读未提交）​
定义​​：事务可读取其他未提交事务的数据。

​​问题​​：脏读（读取到未提交的脏数据）。

​​场景​​：仅用于调试或对一致性要求极低的场景（如日志分析）。
## READ COMMITTED（读已提交）​
定义​​：事务只能读取已提交的数据。

​​改进​​：避免脏读。

​​问题​​：不可重复读（同一事务内多次读取同一字段可能得到不同结果）。

​​典型数据库​​：Oracle、SQL Server 默认隔离级别。
## REPEATABLE READ（可重复读）​
定义​​：确保同一事务内多次读取同一数据结果一致。

​​改进​​：避免脏读、不可重复读。

​​问题​​：幻读（同一事务内多次查询可能发现新增记录）。

​​典型数据库​​：MySQL InnoDB 引擎默认隔离级别（通过 MVCC 和间隙锁解决幻读）。
## SERIALIZABLE（串行化）​
​​定义​​：事务完全串行执行，强制加锁避免并发。

​​改进​​：避免所有并发问题。

​​缺点​​：性能最低，锁竞争激烈时可能导致死锁。

​​场景​​：金融系统等对一致性要求极高的场景。
# SQL 基础
### 数据定义
~~~
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    department VARCHAR(50)
);
~~~
~~~
-- 添加列
ALTER TABLE employees ADD COLUMN salary DECIMAL(10, 2);
-- 删除列
ALTER TABLE employees DROP COLUMN age;
DROP TABLE employees;
~~~
## 数据查询
~~~
SELECT * FROM employees WHERE department = 'HR';
SELECT * FROM employees ORDER BY salary DESC;
SELECT COUNT(*) FROM employees;
SELECT AVG(salary) FROM employees;
SELECT department, COUNT(*) FROM employees GROUP BY department;
~~~
### 数据操作
~~~
INSERT INTO employees (id, name, department, salary) VALUES (1, 'John Doe', 'HR', 5000.00);
UPDATE employees SET salary = 5500.00 WHERE id = 1;
DELETE FROM employees WHERE id = 1;
~~~
### 数据控制
~~~
GRANT SELECT, INSERT ON employees TO 'user'@'localhost';
REVOKE INSERT ON employees FROM 'user'@'localhost';
~~~
